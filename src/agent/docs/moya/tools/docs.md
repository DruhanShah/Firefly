# Moya Tools Documentation

This document provides comprehensive details on the various tools included in the Moya project. The following sections cover the documentation for each tool: `tool_registry.py`, `__init__.py`, `base_tool.py`, and `ephemeral_memory.py`.

---

## Documentation for tool_registry.py

### ToolRegistry for Moya

#### Purpose
The `ToolRegistry` class serves as a centralized management system for various tools in Moya. It allows agents to discover and use these tools dynamically based on inputsâ€”particularly from Language Learning Models (LLMs).

#### Functionality
The `ToolRegistry` class manages tools by enabling their registration, retrieval, and invocation. It also processes tool-related commands from responses generated by different LLM providers such as OpenAI, Bedrock, and Ollama.

#### Key Components

- **ToolRegistry Class**
  - `__init__`: Initializes an empty registry for tools.
  - `register_tool`: Registers a tool in the registry. If a tool with the same name already exists, it gets overwritten.
  - `get_tool`: Retrieves a tool by name from the registry.
  - `get_tools`: Returns all registered tools.
  - `handle_tool_call`: Processes tool calls from LLM responses. It extracts tool calls, retrieves the relevant tools, executes the functions, and collects the results or errors.
  - `_extract_tool_calls`: Extracts tool call details from LLM responses, accommodating different LLM provider formats.

- **BaseTool Class**
  - The `BaseTool` class (imported from `moya.tools.base_tool`) represents the base structure for tools. Each tool is assumed to have a `name` and a `function` that can be invoked.

- **LLMProviders Constants**
  - Constants imported from `moya.utils.constants` define recognized LLM providers (e.g., OpenAI, Bedrock, Ollama). These constants guide how tool calls are extracted based on the provider format.

#### Usage Example
To use the `ToolRegistry`, create tool classes that inherit from `BaseTool` and register them with the registry. Below is an example:

```python
from moya.tools.base_tool import BaseTool
from moya.tools.tool_registry import ToolRegistry

class MemoryTool(BaseTool):
    def __init__(self):
        self.name = "MemoryTool"
        self.function = self.store_memory
    
    def store_memory(self, data):
        # Implementation of memory storage.
        return "Memory stored"

# Initialize the registry.
registry = ToolRegistry()

# Register a tool.
memory_tool = MemoryTool()
registry.register_tool(memory_tool)

# Retrieve and use the tool.
tool = registry.get_tool("MemoryTool")
result = tool.function(data="Important info")
print(result)  # Outputs: Memory stored
```

#### Rationale
The `ToolRegistry` abstracts the management of tools, making it easier to add, find, and use tools based on dynamic inputs. This design promotes modularity and a clean separation of logic, as tools can be developed and tested individually.

#### Additional Information

- **Edge Cases**
  - Registering multiple tools with the same name results in the last registered tool overwriting earlier ones.
  - Improperly formatted tool calls in LLM responses are handled gracefully by reporting errors.

- **Limitations**
  - The `handle_tool_call` function assumes that each tool has a callable `function` attribute. Additional handling is needed if a different interface is used.
  - The parsing logic in `_extract_tool_calls` might require adjustments to accommodate changes in LLM provider response formats.

---

## Documentation for __init__.py

It appears that the code snippet provided for `__init__.py` is empty. Please provide a valid code snippet for further analysis and documentation generation.

---

## Documentation for base_tool.py

### BaseTool for Moya

#### Purpose
The `BaseTool` class represents a generic interface for a "tool" that an agent can discover and invoke. It facilitates the definition, validation, and description of tool parameters and their conversion to various platform-compatible formats.

#### Functionality
The `BaseTool` class allows you to define a tool with a name, description, functionality (as a function), parameters, and a list of required parameters. It ensures that the defined tool adheres to the expected format by validating the parameters and extracting information from the function's docstring if necessary.

#### Key Components

- **Attributes**
  - `name`: The name of the tool.
  - `description`: An optional description of the tool.
  - `function`: An optional callable that implements the tool's functionality.
  - `parameters`: An optional dictionary describing the tool's parameters and their properties.
  - `required`: An optional list of required parameter names.
  
- **Methods**
  - `__post_init__()`: Validates that the function and parameters are properly set and extracts descriptions and types from the function's docstring, if necessary.
  - `_validate_parameters(parameters)`: Validates the provided parameters dictionary.
  - `get_bedrock_definition()`: Returns the tool definition in a Bedrock-compatible format.
  - `get_openai_definition()`: Returns the tool definition in an OpenAI-compatible format.
  - `get_ollama_definition()`: Returns the tool definition in an Ollama-compatible format.

#### Rationale
This class abstracts the common functionality needed to define and use tools across different platforms, ensuring consistency and reducing redundancy. It leverages Python's `dataclass`, type hinting, and docstring conventions for a concise and expressive implementation.

#### Usage Example

Below is an example demonstrating how to use the `BaseTool` class to define a tool with a sample function and retrieve its definition.

```python
from moya.tools.base_tool import BaseTool
from typing import Optional

def example_function(param1: str, param2: int) -> str:
    """
    Example function description.

    Parameters:
    - param1: Description of param1.
    - param2: Description of param2.

    Returns:
    - A string result by combining param1 and param2.
    """
    return f"{param1} {param2}"

# Create an instance of BaseTool.
tool = BaseTool(
    name="ExampleTool",
    function=example_function
)

# Print definitions in different formats.
print(tool.get_bedrock_definition())
print(tool.get_openai_definition())
print(tool.get_ollama_definition())
```

#### Additional Information

- **Dependencies**
  - This class relies on Python modules such as `abc`, `dataclasses`, and `typing`.
  
- **Edge Cases**
  - Ensure that functions provided to the tool have well-documented docstrings for accurate parameter extraction.
  
- **Limitations**
  - The current implementation assumes a specific docstring format and parameter description style.

---

## Documentation for ephemeral_memory.py

### EphemeralMemory Tool for Conversation Data

#### Purpose
The `EphemeralMemory` class provides functionalities to store and retrieve conversation data in memory. It is especially useful for managing conversational threads and messages in chat systems or conversational agents.

#### Functionality

- **store_message**
  - Stores a message in a specified thread. If the thread does not exist, it creates a new one.
  - **Parameters:**
    - `thread_id`: Unique identifier for the conversation thread.
    - `sender`: Sender of the message (e.g., 'user', 'agent').
    - `content`: The message content.
    - `metadata`: Optional metadata dictionary.
  - **Returns:** A confirmation message indicating that the message was stored.

- **get_last_n_messages**
  - Retrieves the last N messages from a specified thread.
  - **Parameters:**
    - `thread_id`: Unique identifier for the conversation thread.
    - `n`: Number of messages to retrieve (default is 5).
  - **Returns:** A JSON representation of the last N messages.

- **get_thread_summary**
  - Generates a naive summary of the conversation thread by concatenating all messages.
  - **Parameters:**
    - `thread_id`: Unique identifier for the conversation thread.
  - **Returns:** A naive summary of the conversation thread.

- **configure_memory_tools**
  - Registers the memory tool with the provided `ToolRegistry`.
  - **Parameters:**
    - `tool_registry`: The tool registry in which the MemoryTool should be registered.

#### Key Components

- **EphemeralMemory**
  - The main class that contains all functionalities to handle conversation data.
  
- **memory_repository**
  - An instance of `InMemoryRepository` that is used for managing messages and threads in memory.

#### Usage Examples

```python
# Example 1: Storing a Message
thread_id = "thread_1"
sender = "user"
content = "Hello, how can I help you today?"
EphemeralMemory.store_message(thread_id, sender, content)

# Example 2: Retrieving the Last 5 Messages
thread_id = "thread_1"
last_messages = EphemeralMemory.get_last_n_messages(thread_id, 5)
print(last_messages)

# Example 3: Generating a Thread Summary
thread_id = "thread_1"
summary = EphemeralMemory.get_thread_summary(thread_id)
print(summary)

# Example 4: Configuring Memory Tools
from moya.tools.tool_registry import ToolRegistry

tool_registry = ToolRegistry()
EphemeralMemory.configure_memory_tools(tool_registry)
```

#### Rationale
The `EphemeralMemory` class is designed for in-memory management of conversation data, making it suitable for quick and temporary data handling. While the naive summarization method is simple, it can be expanded with more sophisticated logic for production use.

#### Additional Information

- **Edge Cases**
  - Non-existing threads are automatically created if needed.
  
- **Limitations**
  - The naive summarization method may not be suitable for all use cases. Custom logic is recommended for generating concise and meaningful summaries.